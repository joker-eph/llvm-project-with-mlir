# RUN: toyc-ch1 %s -emit=ast 2>&1 | FileCheck %s


# User defined generic function that operates solely on 
def multiply_transpose(a, b) {
  return a * transpose(b);
}

def main() {
  # Define a variable `a` with shape <2, 3>, initialized with the literal value
  var a<2, 3> = [[1, 2, 3], [4, 5, 6]];
  var b<2, 3> = [1, 2, 3, 4, 5, 6];
  # This call will specialize `multiply_transpose` with <2, 3> for both
  # arguments and deduce a return type of <2, 2> in initialization of `c`.
  var c = multiply_transpose(a, b);
  # A second call to `multiply_transpose` with <2, 3> for both arguments will
  # reuse the previously specialized and inferred version and return `<2, 2>`
  var d = multiply_transpose(b, a);
  # A new call with `<2, 2>` for both dimension will trigger another
  # specialization of `multiply_transpose`.
  var e = multiply_transpose(b, c);
  # Finally, calling into `multiply_transpose` with incompatible shape will
  # trigger a shape inference error.
  var e = multiply_transpose(transpose(a), c);
}


# CHECK: Module:
# CHECK-NEXT:     Function 
# CHECK-NEXT:       Proto 'multiply_transpose' 
# CHECK-NEXT:       Params: [a, b]
# CHECK-NEXT:       Block {
# CHECK-NEXT:         Retur
# CHECK-NEXT:           BinOp: * 
# CHECK-NEXT:             var: a 
# CHECK-NEXT:             Call 'transpose' [ 
# CHECK-NEXT:               var: b 
# CHECK-NEXT:             ]
# CHECK-NEXT:       } // Block
# CHECK-NEXT:     Function 
# CHECK-NEXT:       Proto 'main' 
# CHECK-NEXT:       Params: []
# CHECK-NEXT:       Block {
# CHECK-NEXT:         VarDecl a<2, 3> 
# CHECK-NEXT:           Literal: <2, 3>[ <3>[ 1.000000e+00, 2.000000e+00, 3.000000e+00], <3>[ 4.000000e+00, 5.000000e+00, 6.000000e+00]] 
# CHECK-NEXT:         VarDecl b<2, 3> 
# CHECK-NEXT:           Literal: <6>[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00] 
# CHECK-NEXT:         VarDecl c<> 
# CHECK-NEXT:           Call 'multiply_transpose' [ 
# CHECK-NEXT:             var: a 
# CHECK-NEXT:             var: b 
# CHECK-NEXT:           ]
# CHECK-NEXT:         VarDecl d<> 
# CHECK-NEXT:           Call 'multiply_transpose' [ 
# CHECK-NEXT:             var: b 
# CHECK-NEXT:             var: a 
# CHECK-NEXT:           ]
# CHECK-NEXT:         VarDecl e<> 
# CHECK-NEXT:           Call 'multiply_transpose' [ 
# CHECK-NEXT:             var: b 
# CHECK-NEXT:             var: c 
# CHECK-NEXT:           ]
# CHECK-NEXT:         VarDecl e<> 
# CHECK-NEXT:           Call 'multiply_transpose' [ 
# CHECK-NEXT:             Call 'transpose' [ 
# CHECK-NEXT:               var: a 
# CHECK-NEXT:             ]
# CHECK-NEXT:             var: c 
# CHECK-NEXT:           ]
# CHECK-NEXT:       } // Block

